# Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### Cтудент: Сарайкин Н.С.
### Вариант: 21 (по списку)

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Обычно, для обработки естественных и искусственных языков используется два подхода - статический и лингвистический. Статический подход в основном используется в императивных языках, так как основан на том, что значение текста заключено в количестве повторений слов, то есть для анализа необходимо подсчитать повторения слов, что удобно делать в императивных языках.

Лингвистический подход более точен, в нем мы разбиваем текст на графемы на основе грамматики языка, чтобы определить семантику текста. Для этого очень хорошо подходит `Prolog`, так как в нем удобная работа со списками, удобный перебор и бэктрекинг, реализована работа со строками. Благодаря перебору фактов в `Prolog`, мы можем реалзовать грамматику не основываясь на их количестве, а потом легко дополнить список фактов, для уже готовой грамматики.

## Вариант ((N-1) mod 10) + 1 = 1

## Задание

Генеалогическое дерево задано фактами вида:
```prolog
parent(alexei,tolia).
parent(alexei,volodia).
parent(tolia,tima).
```
Написать программу на Прологе, запросы к которой будут выглядеть следующим образом:

---

Запросы: 
```prolog
?- answer([volodia, brat , toli, ‘?’],X). 
?- answer([kto, tolin, brat, ‘?’],X). 
?- answer([chei, brat, volodia, ‘?’],X). 
```
Результаты:    X=yes, X=volodia, X=tolia. 

## Принцип решения

Я разбил правила для замены нетерминальных символов на терминальные. В одном правиле я храню имена в разных падежах и частях речи, а в другом - местоимения и слова для выбора предиката.

```prolog
gen1(File1):-File1=[
    alexei:sost("именит"):[alexei],
    tolia:sost("именит"):[tolia],
    volodia:sost("именит"):[volodia],
    tima:sost("именит"):[tima],
    sasha:sost("именит"):[sasha],
    mitia:sost("именит"):[mitia],
    alexei:sost("родит"):[alexia],
    tolia:sost("родит"):[toli],
    volodia:sost("родит"):[volodi],
    tima:sost("родит"):[timi],
    sasha:sost("родит"):[sashi],
    mitia:sost("родит"):[miti],
    alexei:sost("прит"):[alexein],
    tolia:sost("прит"):[tolin],
    volodia:sost("прит"):[volodin],
    sasha:sost("прит"):[sashin],
    mitia:sost("прит"):[mitin],
    tima:sost("прит"):[timin]].

gen2(File2):-File2=[
    kto:sost("именит"):[kto],
    kto:sost("прит"):[chei],
    brat:sost("предикат"):[brat],
    otez:sost("предикат"):[otez]].
```

Далее мы описываем предикаты для разбиения списка на факты и удобного поиска терминального символа, как пример нетерминальный символ tolin, заменится на tolia.

```prolog
fid(X, XC, K, File):-member(M,File), condition(X, XC, K, M).
condition(X, XC, K, XC:K:L):-member(X, L).
```

Когда мы вводим предложение, мы преобразуем нетерминальные символы в терминальные и передаем их в предикат для выбора предиката утверждения, в котором, в свою очередь, на основе слова для определения предиката он исполняется, вызывая предикат родства. 

```prolog
an_phrase([X,Y,Z,"?"],Predic) :-an_obj(X1, sost("именит"), X), an_funct(X2, sost("предикат"),Y),an_obj(X3, sost("родит"),Z),swi_ped(X2,X1,X3,Predic).
an_phrase([X,Y,Z,"?"],Predic) :-an_funct(_, sost("именит"), X), an_obj(X2, sost("прит"),Y), an_funct(X3, sost("предикат"),Z), swi_ped(X3,X2,Predic).
an_phrase([X,Y,Z,"?"],Predic) :-an_funct(_, sost("прит"), X), an_funct(X2, sost("предикат"),Y),an_obj(X3, sost("именит"),Z), swi_ped(X2,X3,Predic).

swi_ped(otez,X,Predic):-parent(X,Predic).
swi_ped(brat,X,Predic):-brat(X,Predic).
swi_ped(brat,X,Y,Predic):-brat(X,Y,Predic).
swi_ped(otez,X,Y,Predic):-parent(X,Y,Predic).
```

Терминальными символами в таком случае являются имена в именительном падеже и слова для выбора предиката(брат, отец). Сущeствительные и местоимения в других падежах являются нетерминальными.
## Результаты

```prolog
?- an_phrase([sasha, brat , miti, "?"],X).
X = yes .
?- an_phrase([kto,timin,otez,"?"],X).
X = tolia .
?- an_phrase([chei,otez,volodia,"?"],X).
X = sasha ;
X = mitia .
```

## Выводы

Данная лабораторная работа познакомила меня и заставила задуматься над разбором семантики естественного языка, а также показала удобство применения логических языков программирования, в часности `Prolog`, для решения этой задачи. Так мы можем естественно расписать грамматику языка и в дальнейшем масштабировать программу за счет фактов. Это можно проследить и на примере моей работы, масштабированный вариант которой, можно взять за основу одного из заданий курсовой работы.

Таким образом мы можем сделать вывод о мощности `Prolog`, как инструмента для грамматического разбора, недостатком которого является наличие большой базы фактов. Данную базу придется либо генерировать другой программой, либо создавать руками.




