# Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### Студент: Сарайкин Н.С.

### Вариант: 21 (по списку)

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Решение логических задач - это особый тип задач программирования, который эффективно решается с использованием логических языков программирования. В частности, *Prolog* основан на логической парадигме программирования (т.е. на математической логике) и преимущество использования *Prolog* заключается в наличии в языке всех необходимых инструментов для этого:
+ *Prolog* имеет встроенный механизм унификации, который позволяет сопоставлять и унифицировать логические выражения и переменные. Благодаря этому механизму *Prolog* может автоматически находить решение для заданной логической задачи и предоставлять все возможные альтернативы.
+ *Prolog* обладает мощной системой вывода, которая позволяет автоматически генерировать ответы на задачу, основываясь на предложенных правилах и фактах. Это упрощает написание решателей логических задач и позволяет сосредоточиться на описании задачи, а не на процессе поиска решения.

Существуют 2 основных подхода к решению логических задач, при этом они оба перебирают некоторый набор решений:
+ **Поиск с возвратом (backtracking)** 
Некоторый предикат генерирует множество исходных данных, которые затем проверяются другими предикатами на предмет соответствия условию задачи. В случае неуспеха происходит возврат к началу дерева, рассматривается следующий набор данных. В случае успеха полученное решение возвращается пользователю или используется дальше. 
+ **Метод ветвей и границ** *(противопоставляется 1-ому подходу).*
Здесь значительные части возможных решений отсекаются на раннем этапе выполнения или вообще не генерируются. Предикаты можно использовать одновременно для проверки и генерации, таким образом, генерируются не все варианты решений, а какое-то их подмножество. Программа, написанная этим способом будет работать быстрее.

## Вариант ((N-1) mod 28) + 1 = 21 

## Задание 

Дима, Герман и Олег  студенты. Каждый из них увлекается тремя предметами из четырех: биологией, химией, историей, математикой. Вот что они говорили о своих склонностях. Герман. Дима  единственный из нас, кто любит историю. Олег и я увлекаемся одними и теми же предметами. Мы все считаем биологию интереснейшей наукой. Двое из нас любят и химию, и биологию. Олег. Нам всем очень нравится математика. Герман  завзятый историк. В одном из увлечений мы расходимся с Димой. Герман и Дима любят химию. Дима. Есть только один предмет, который любим мы все. Математикой увлекаюсь я один. Каждый из нас любит разное сочетание дисциплин. Олег ошибается, говоря, что Герман и я увлекаемся химией. Известно, что только два из утверждений каждого студента соответствуют действительности. Попробуйте сказать, какими науками увлекается каждый из них?

## Принцип решения

Преобразовываем высказывания из условия задачи в следующие правила (на каждого по 4 высказывания):
```prolog
% info(<имя>, <номер высказывания>,<список студентов(студенты - списки)>)
info(g, 1, [Ge, Ol, Di]) :- member(history, Di), not(member(history, Ge)), not(member(history, Ol)). % Дима единственный из нас, кто любит историю.
info(g, 2, [Ge, Ol,_]) :- crossing_sets(Ge, Ol, L), length(L, 3). % Олег и я увлекаемся одними и теми же предметами.
info(g, 3, [Ge, Ol, Di]) :- member(biology, Ge), member(biology, Ol), member(biology, Di). % Мы все считаем биологию интереснейшей наукой
info(g, 4, [Ge, Ol, Di]) :- same_subject([Ge, Ol, Di]). % Двое из нас любят и химию, и биологию.

info(o, 1, [Ge, Ol, Di]) :- member(math, Ge), member(math, Ol), member(math, Di). % Нам всем очень нравится математика.
info(o, 2, [Ge,_,_]) :- member(history, Ge). % Герман завзятый историк.
info(o, 3, [_, Ol, Di]) :- subtraction(Ol, Di, L), length(L, 1). % В одном из увлечений мы расходимся с Димой.
info(o, 4, [Ge,_, Di]) :- member(chemistry, Ge), member(chemistry, Di). % Герман и Дима любят химию. 

info(d, 1, [Ge, Ol, Di]) :- crossing_sets(Ge, Ol, L1), crossing_sets(Di, L1, L2), length(L2, 1). %  Есть только один предмет, который любим мы все.
info(d, 2, [Ge, Ol, Di]) :- not(member(math, Ge)), not(member(math, Ol)), member(math, Di). % Математикой увлекаюсь я один.
info(d, 3, [Ge, Ol, Di]) :- crossing_sets(Ge, Ol, L1), crossing_sets(Ge, Di, L2), crossing_sets(Di, Ol, L3), % Каждый из нас любит разное сочетание дисциплин. 
                           length(L1, I1),length(L2, I2),length(L3, I3), I1 < 3, I2 < 3, I3 < 3. 
info(d, 4, [Ge,_, Di]) :- not(info(o, 4, [Ge,_, Di])). % Олег ошибается, говоря, что Герман и я увлекаемся химией.
```
Однако для этого нам понадобилось несколько специальных предикатов:
```prolog
% Когда увлекаются одними и теми же предметами (Биология, Химия)
same_subject([Ger, Oleg,_]) :- member(biology, Ger), member(chemistry, Ger), member(biology, Oleg), member(chemistry, Oleg).
same_subject([Ger,_, Dima]) :- member(biology, Ger), member(chemistry, Ger), member(biology, Dima), member(chemistry, Dima).
same_subject([_, Oleg, Dima]) :- member(biology, Dima), member(chemistry, Dima), member(biology, Oleg), member(chemistry, Oleg).

% Пересечение множеств на основе списков
crossing_sets([],_, []).
crossing_sets([H|T], Y, [H|R]) :- memb(H, Y), crossing_sets(T, Y, R), !.
crossing_sets([_|T], Y, R) :- crossing_sets(T, Y, R), !.

memb(_, []) :- fail.
memb(X, [X|_]) :- !.
memb(X, [_|T]) :- memb(X, T).

% Вычитание списка из списка
subtraction([], _, []) :- !.
subtraction([A|C], B, D) :- member(A, B), !, subtraction(C, B, D).
subtraction([A|B], C, [A|D]) :- subtraction(B, C, D).
```

Так как только 2 из 4 высказываний студентов верны, их нужно перебирать:
```prolog
elems([T1, T2, L1, L2], T1, T2, L1, L2). % Связываем значения [T1, T2, L1, L2] с остальными элементами списка для перебора

% Перебираем все возможные утверждения кого-то из студентов
check(Z, V) :-
        permutation([1, 2, 3, 4], P), elems(P, T1, T2, L1, L2),
        info(Z, T1, V), info(Z, T2, V), not(info(Z, L1, V)), not(info(Z, L2, V)). % Должны выполняться только два info, так как по условию только два высказывания верны
```

Теперь реализуем предикат поиска решения с помощью `permutation`:

```prolog
takethree([_|T], T) :- length(T, 3). % Возвращает последние 3 элемента списка
        
solve(Ger,Oleg,Dima) :-
        permutation([biology, chemistry, math, history], Ge),
        permutation([biology, chemistry, math, history], Ol),
        permutation([biology, chemistry, math, history], Di),
        takethree(Ge, Ger), takethree(Ol, Oleg), takethree(Di, Dima),
        check(g, [Ger, Oleg, Dima]), check(o, [Ger, Oleg, Dima]), check(d, [Ger, Oleg, Dima]), !. % Возвращаем первое найденное решение
```

## Выводы

Эта лабораторная работа помогла мне освоить принципы решения логических задач на языке программирования *Prolog*. Могу сделать вывод, что языки программирования, основанные на логической парадигме, чаще всего лучше подходят для решения задач, связанных с логикой, так как из-за специфики *Prolog* решения реализуются довольно просто. Несмотря на простоту приходится идти на компромисс с эффективностью из-за того что все подходы к решению подразумевают так или иначе переборный метод.




